"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Effect = require("../Effect/index.js");
var Effect_Ref = require("../Effect.Ref/index.js");
var Effect_Unsafe = require("../Effect.Unsafe/index.js");
var Safe_Coerce = require("../Safe.Coerce/index.js");
var Unsafe_Reference = require("../Unsafe.Reference/index.js");

// | A `Subscription` results from subscribing to an `Emitter` with `subscribe`;
// | the subscription can be ended at any time with `unsubscribe`.
var Subscription = function (x) {
    return x;
};

// | Conceptually, a `Listener` represents an input source to an `Emitter`. You
// | can push a value to its paired emitter with the `notify` function.
var Listener = function (x) {
    return x;
};

// | An `Emitter` represents a collection of discrete occurrences of an event;
// | conceptually, an emitter is a possibly-infinite list of values.
// |
// | Emitters are created from real events like timers or mouse clicks and can
// | be combined or transformed with the functions and instances in this module.
// |
// | Emitters are consumed by providing a callback via the `subscribe` function.
var Emitter = function (x) {
    return x;
};

// | End a subscription to an `Emitter`.
var unsubscribe = function (v) {
    return v;
};

// | Subscribe to an `Emitter` by providing a callback to run on values produced
// | by the emitter:
// |
// | ```purs
// | -- Produce an emitter / listener pair with `create`:
// | { emitter, listener } <- create
// |
// | -- Then, subscribe to the emitter by providing a callback:
// | subscription <- subscribe emitter \emitted ->
// |   doSomethingWith emitted
// |
// | -- End the subscription at any time with `unsubscribe`:
// | unsubscribe subscription
// | ```
var subscribe = function (v) {
    return function (k) {
        return v((function () {
            var $55 = Data_Functor["void"](Effect.functorEffect);
            return function ($56) {
                return $55(k($56));
            };
        })());
    };
};
var semigroupSubscription = Effect.semigroupEffect(Data_Semigroup.semigroupUnit);

// | Push a value to the `Emitter` paired with the provided `Listener` argument.
// |
// | ```purs
// | -- Create an emitter and listener with `create`:
// | { emitter, listener } <- create
// |
// | -- Then, push values to the emitter via the listener with `notify`:
// | notify listener "hello"
// | ```
var notify = function (v) {
    return function (a) {
        return v(a);
    };
};
var monoidSubscription = Effect.monoidEffect(Data_Monoid.monoidUnit);

// | Make an `Emitter` from a function which accepts a callback and returns an
// | unsubscription function.
// |
// | Note: You should use `create` unless you need explicit control over
// | unsubscription.
var makeEmitter = Safe_Coerce.coerce();
var functorEmitter = {
    map: function (f) {
        return function (v) {
            return function (k) {
                return v(function ($57) {
                    return k(f($57));
                });
            };
        };
    }
};

// | Fold over values received from some `Emitter`, creating a new `Emitter`.
var fold = function (f) {
    return function (v) {
        return function (b) {
            return function (k) {
                return function __do() {
                    var result = Effect_Ref["new"](b)();
                    return v(function (a) {
                        return Control_Bind.bind(Effect.bindEffect)(Effect_Ref.modify(f(a))(result))(k);
                    })();
                };
            };
        };
    };
};

// | Create an `Emitter` which only fires when a predicate holds.
var filter = function (p) {
    return function (v) {
        return function (k) {
            return v(function (a) {
                var $36 = p(a);
                if ($36) {
                    return k(a);
                };
                return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
            });
        };
    };
};

// | Create a paired `Listener` and `Emitter`, where you can push values to
// | the listener and subscribe to values from the emitter.
// |
// | ```purs
// | { emitter, listener } <- create
// |
// | -- Push values into the listener:
// | notify listener "hello"
// |
// | -- Subscribe to outputs from the emitter with a callback:
// | subscription <- subscribe emitter \value ->
// |   Console.log value
// |
// | -- Unsubscribe at any time:
// | unsubscribe subscription
// | ```
var create = function __do() {
    var subscribers = Effect_Ref["new"]([  ])();
    return {
        emitter: function (k) {
            return function __do() {
                Effect_Ref.modify_(function (v) {
                    return Data_Semigroup.append(Data_Semigroup.semigroupArray)(v)([ k ]);
                })(subscribers)();
                return Effect_Ref.modify_(Data_Array.deleteBy(Unsafe_Reference.unsafeRefEq)(k))(subscribers);
            };
        },
        listener: function (a) {
            return Control_Bind.bind(Effect.bindEffect)(Effect_Ref.read(subscribers))(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(function (k) {
                return k(a);
            }));
        }
    };
};

// | Compute a fixed point.
var fix = function (f) {
    var v = Effect_Unsafe.unsafePerformEffect(create);
    var v1 = f(v.emitter);
    return function (k) {
        return function __do() {
            var v2 = subscribe(v1.input)(notify(v.listener))();
            var v3 = subscribe(v1.output)(k)();
            return Control_Apply.applySecond(Effect.applyEffect)(v2)(v3);
        };
    };
};
var contravariantListener = {
    cmap: function (f) {
        return function (v) {
            return Safe_Coerce.coerce()(function ($58) {
                return v(f($58));
            });
        };
    }
};
var applyEmitter = {
    apply: function (v) {
        return function (v1) {
            return function (k) {
                return function __do() {
                    var latestA = Effect_Ref["new"](Data_Maybe.Nothing.value)();
                    var latestB = Effect_Ref["new"](Data_Maybe.Nothing.value)();
                    var v2 = v(function (a) {
                        return function __do() {
                            Effect_Ref.write(new Data_Maybe.Just(a))(latestA)();
                            return Control_Bind.bind(Effect.bindEffect)(Effect_Ref.read(latestB))(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(function ($59) {
                                return k(a($59));
                            }))();
                        };
                    })();
                    var v3 = v1(function (b) {
                        return function __do() {
                            Effect_Ref.write(new Data_Maybe.Just(b))(latestB)();
                            return Control_Bind.bind(Effect.bindEffect)(Effect_Ref.read(latestA))(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(function ($60) {
                                return k((function (v3) {
                                    return v3(b);
                                })($60));
                            }))();
                        };
                    })();
                    return Control_Apply.applySecond(Effect.applyEffect)(v2)(v3);
                };
            };
        };
    },
    Functor0: function () {
        return functorEmitter;
    }
};
var semigroupEmitter = function (dictSemigroup) {
    return {
        append: Control_Apply.lift2(applyEmitter)(Data_Semigroup.append(dictSemigroup))
    };
};
var monoidEmitter = function (dictMonoid) {
    return {
        mempty: Data_Monoid.mempty(Data_Monoid.monoidFn(Effect.monoidEffect(monoidSubscription))),
        Semigroup0: function () {
            return semigroupEmitter(dictMonoid.Semigroup0());
        }
    };
};
var applicativeEmitter = {
    pure: function (a) {
        return function (k) {
            return function __do() {
                k(a)();
                return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
            };
        };
    },
    Apply0: function () {
        return applyEmitter;
    }
};
var altEmitter = {
    alt: function (v) {
        return function (v1) {
            return function (k) {
                return function __do() {
                    var v2 = v(k)();
                    var v3 = v1(k)();
                    return Control_Apply.applySecond(Effect.applyEffect)(v2)(v3);
                };
            };
        };
    },
    Functor0: function () {
        return functorEmitter;
    }
};
var plusEmitter = {
    empty: function (v) {
        return Control_Applicative.pure(Effect.applicativeEffect)(Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit));
    },
    Alt0: function () {
        return altEmitter;
    }
};
var alternativeEmitter = {
    Applicative0: function () {
        return applicativeEmitter;
    },
    Plus1: function () {
        return plusEmitter;
    }
};
module.exports = {
    create: create,
    notify: notify,
    makeEmitter: makeEmitter,
    subscribe: subscribe,
    unsubscribe: unsubscribe,
    fold: fold,
    filter: filter,
    fix: fix,
    functorEmitter: functorEmitter,
    applyEmitter: applyEmitter,
    applicativeEmitter: applicativeEmitter,
    altEmitter: altEmitter,
    plusEmitter: plusEmitter,
    alternativeEmitter: alternativeEmitter,
    semigroupEmitter: semigroupEmitter,
    monoidEmitter: monoidEmitter,
    contravariantListener: contravariantListener,
    semigroupSubscription: semigroupSubscription,
    monoidSubscription: monoidSubscription
};
