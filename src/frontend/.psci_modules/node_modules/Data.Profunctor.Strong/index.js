"use strict";
var Control_Category = require("../Control.Category/index.js");
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Profunctor = require("../Data.Profunctor/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var strongFn = {
    first: function (a2b) {
        return function (v) {
            return new Data_Tuple.Tuple(a2b(v.value0), v.value1);
        };
    },
    second: Data_Functor.map(Data_Tuple.functorTuple),
    Profunctor0: function () {
        return Data_Profunctor.profunctorFn;
    }
};
var second = function (dict) {
    return dict.second;
};
var first = function (dict) {
    return dict.first;
};

// | Compose a value acting on a `Tuple` from two values, each acting on one of
// | the components of the `Tuple`.
// |
// | Specializing `(***)` to function application would look like this:
// | ```
// | (***) :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)
// | ```
// | We take two functions, `f` and `g`, and we transform them into a single function which
// | takes a `Tuple` and maps `f` over the first element and `g` over the second.  Just like `bi-map`
// | would do for the `bi-functor` instance of `Tuple`.
var splitStrong = function (dictCategory) {
    return function (dictStrong) {
        return function (l) {
            return function (r) {
                return Control_Semigroupoid.composeFlipped(dictCategory.Semigroupoid0())(first(dictStrong)(l))(second(dictStrong)(r));
            };
        };
    };
};

// | Compose a value which introduces a `Tuple` from two values, each introducing
// | one side of the `Tuple`.
// |
// | This combinator is useful when assembling values from smaller components,
// | because it provides a way to support two different types of output.
// |
// | Specializing `(&&&)` to function application would look like this:
// | ```
// | (&&&) :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))
// | ```
// | We take two functions, `f` and `g`, with the same parameter type and we transform them into a
// | single function which takes one parameter and returns a `Tuple` of the results of running
// | `f` and `g` on the parameter, respectively.  This allows us to run two parallel computations
// | on the same input and return both results in a `Tuple`.
var fanout = function (dictCategory) {
    return function (dictStrong) {
        return function (l) {
            return function (r) {
                var split = Data_Profunctor.dimap(dictStrong.Profunctor0())(Control_Category.identity(Control_Category.categoryFn))(function (a) {
                    return new Data_Tuple.Tuple(a, a);
                })(Control_Category.identity(dictCategory));
                return Control_Semigroupoid.composeFlipped(dictCategory.Semigroupoid0())(split)(splitStrong(dictCategory)(dictStrong)(l)(r));
            };
        };
    };
};
module.exports = {
    first: first,
    second: second,
    splitStrong: splitStrong,
    fanout: fanout,
    strongFn: strongFn
};
